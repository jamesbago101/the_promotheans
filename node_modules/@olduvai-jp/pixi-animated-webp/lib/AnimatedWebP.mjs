import { Sprite, Texture, DOMAdapter, Ticker, UPDATE_PRIORITY } from 'pixi.js';

const _AnimatedWebP = class extends Sprite {
  constructor(frames, options) {
    super(Texture.EMPTY);
    this.animationSpeed = 1;
    this.loop = true;
    this.duration = 0;
    this.autoPlay = true;
    this.dirty = false;
    this._currentFrame = 0;
    this._autoUpdate = false;
    this._isConnectedToTicker = false;
    this._playing = false;
    this._currentTime = 0;
    this.onRender = () => this.updateFrame();
    const { scaleMode, width, height, ...rest } = Object.assign(
      {},
      _AnimatedWebP.defaultOptions,
      options
    );
    const canvas = DOMAdapter.get().createCanvas(width, height);
    const context = canvas.getContext("2d", { willReadFrequently: true });
    this.texture = Texture.from(canvas);
    this.texture.source.scaleMode = scaleMode;
    this.duration = frames[frames.length - 1].end;
    this._frames = frames;
    this._context = context;
    this._playing = false;
    this._currentTime = 0;
    this._isConnectedToTicker = false;
    Object.assign(this, rest);
    this.currentFrame = 0;
    if (rest.autoPlay) {
      this.play();
    }
  }
  static async fromBuffer(buffer, options) {
    if (!buffer || buffer.byteLength === 0) {
      throw new Error("Invalid buffer");
    }
    if (typeof ImageDecoder === "undefined") {
      console.error("ImageDecoder API is not supported in this environment");
      throw new Error("ImageDecoder API is not supported in this environment");
    }
    const decoder = new ImageDecoder({ data: buffer, type: "image/webp" });
    await decoder.tracks.ready;
    if (decoder.tracks.length === 0) {
      throw new Error("No tracks found in WebP");
    }
    const track = decoder.tracks.selectedTrack;
    if (!track) {
      throw new Error("No selected track found in WebP");
    }
    const frameCount = track.frameCount;
    const frames = [];
    const canvas = DOMAdapter.get().createCanvas();
    const context = canvas.getContext("2d", { willReadFrequently: true });
    let totalDuration = 0;
    for (let i = 0; i < frameCount; i++) {
      const { image, complete } = await decoder.decode({ frameIndex: i });
      if (!image || !complete) {
        continue;
      }
      const duration = image.duration / 1e3;
      canvas.width = image.displayWidth;
      canvas.height = image.displayHeight;
      context.drawImage(image, 0, 0);
      const imageData = context.getImageData(0, 0, image.displayWidth, image.displayHeight);
      frames.push({
        imageData,
        start: totalDuration,
        end: totalDuration + duration
      });
      totalDuration += duration;
      image.close();
    }
    decoder.close();
    if (frames.length === 0) {
      throw new Error("No frames decoded from WebP");
    }
    const { width, height } = frames[0].imageData;
    return new _AnimatedWebP(frames, { width, height, ...options });
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
    if (!this.loop && this.currentFrame === this._frames.length - 1) {
      this._currentTime = 0;
    }
  }
  get progress() {
    return this._currentTime / this.duration;
  }
  get playing() {
    return this._playing;
  }
  update(ticker) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * ticker.elapsedMS;
    this._currentTime += elapsed;
    const localTime = this._currentTime % this.duration;
    const frameIndex = this._frames.findIndex((frame) => localTime >= frame.start && localTime < frame.end);
    if (frameIndex === -1) {
      return;
    }
    if (this._currentTime >= this.duration) {
      if (this.loop) {
        this._currentTime = localTime;
        this.updateFrameIndex(frameIndex);
        this.onLoop?.();
      } else {
        this._currentTime = this.duration;
        this.updateFrameIndex(this.totalFrames - 1);
        this.onComplete?.();
        this.stop();
      }
    } else {
      this.updateFrameIndex(frameIndex);
    }
  }
  updateFrame() {
    if (!this.dirty) {
      return;
    }
    const { imageData } = this._frames[this._currentFrame];
    this._context.putImageData(imageData, 0, 0);
    this._context.fillStyle = "transparent";
    this._context.fillRect(0, 0, 0, 1);
    this.texture.source.update();
    this.dirty = false;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get currentFrame() {
    return this._currentFrame;
  }
  set currentFrame(value) {
    this.updateFrameIndex(value);
    this._currentTime = this._frames[value].start;
  }
  updateFrameIndex(value) {
    if (value < 0 || value >= this._frames.length) {
      throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${value}`);
    }
    if (this._currentFrame !== value) {
      this._currentFrame = value;
      this.dirty = true;
      this.onFrameChange?.(value);
    }
  }
  get totalFrames() {
    return this._frames.length;
  }
  destroy() {
    this.stop();
    super.destroy(true);
    const forceClear = null;
    this._context = forceClear;
    this._frames = forceClear;
    this.onComplete = forceClear;
    this.onFrameChange = forceClear;
    this.onLoop = forceClear;
  }
  static fromFrames(frames, autoUpdate = true) {
    if (!frames || frames.length === 0) {
      throw new Error("No frames provided");
    }
    const { width, height } = frames[0].imageData;
    return new _AnimatedWebP(frames, {
      width,
      height,
      autoUpdate
    });
  }
  static fromImageData(imageData, duration = 1e3) {
    const frame = {
      imageData,
      start: 0,
      end: duration
    };
    return new _AnimatedWebP([frame], {
      width: imageData.width,
      height: imageData.height
    });
  }
  clone() {
    return new _AnimatedWebP(this._frames, {
      width: this.texture.width,
      height: this.texture.height,
      scaleMode: this.texture.source.scaleMode,
      animationSpeed: this.animationSpeed,
      loop: this.loop,
      autoPlay: false,
      autoUpdate: this._autoUpdate,
      onComplete: this.onComplete,
      onFrameChange: this.onFrameChange,
      onLoop: this.onLoop
    });
  }
};
let AnimatedWebP = _AnimatedWebP;
AnimatedWebP.defaultOptions = {
  scaleMode: "linear",
  fps: 30,
  loop: true,
  animationSpeed: 1,
  autoPlay: true,
  autoUpdate: true,
  onComplete: null,
  onFrameChange: null,
  onLoop: null
};

export { AnimatedWebP };
//# sourceMappingURL=AnimatedWebP.mjs.map
