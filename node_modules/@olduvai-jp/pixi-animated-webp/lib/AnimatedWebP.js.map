{"version":3,"file":"AnimatedWebP.js","sources":["../src/AnimatedWebP.ts"],"sourcesContent":["import { DOMAdapter, SCALE_MODE, Sprite, Texture, Ticker, UPDATE_PRIORITY } from 'pixi.js';\n\n/** Represents a single frame of a WebP. Includes image and timing data. */\ninterface FrameObject\n{\n    /** Image data for the current frame */\n    imageData: ImageData;\n    /** The start of the current frame, in milliseconds */\n    start: number;\n    /** The end of the current frame, in milliseconds */\n    end: number;\n}\n\n/** Default options for all AnimatedWebP objects. */\ninterface AnimatedWebPOptions\n{\n    /** Whether to start playing right away */\n    autoPlay: boolean;\n    /**\n     * Scale Mode to use for the texture\n     * @type {PIXI.SCALE_MODE}\n     */\n    scaleMode: SCALE_MODE;\n    /** To enable looping */\n    loop: boolean;\n    /** Speed of the animation */\n    animationSpeed: number;\n    /** Set to `false` to manage updates yourself */\n    autoUpdate: boolean;\n    /** The completed callback, optional */\n    onComplete: null | (() => void);\n    /** The loop callback, optional */\n    onLoop: null | (() => void);\n    /** The frame callback, optional */\n    onFrameChange: null | ((currentFrame: number) => void);\n    /** Fallback FPS if WebP contains no time information */\n    fps?: number;\n}\n\n/** Options for the AnimatedWebP constructor. */\ninterface AnimatedWebPSize\n{\n    /** Width of the WebP image */\n    width: number;\n    /** Height of the WebP image */\n    height: number;\n}\n\n/**\n * Runtime object to play animated WebPs. This object is similar to an AnimatedSprite.\n * It support playback (seek, play, stop) as well as animation speed and looping.\n * @see Uses ImageDecoder API for WebP decoding\n */\nclass AnimatedWebP extends Sprite\n{\n    /**\n     * Default options for all AnimatedWebP objects.\n     * @property {PIXI.SCALE_MODE} [scaleMode='linear'] - Scale mode to use for the texture.\n     * @property {boolean} [loop=true] - To enable looping.\n     * @property {number} [animationSpeed=1] - Speed of the animation.\n     * @property {boolean} [autoUpdate=true] - Set to `false` to manage updates yourself.\n     * @property {boolean} [autoPlay=true] - To start playing right away.\n     * @property {Function} [onComplete=null] - The completed callback, optional.\n     * @property {Function} [onLoop=null] - The loop callback, optional.\n     * @property {Function} [onFrameChange=null] - The frame callback, optional.\n     * @property {number} [fps=30] - Fallback FPS if WebP contains no time information.\n     */\n    public static defaultOptions: AnimatedWebPOptions = {\n        scaleMode: 'linear',\n        fps: 30,\n        loop: true,\n        animationSpeed: 1,\n        autoPlay: true,\n        autoUpdate: true,\n        onComplete: null,\n        onFrameChange: null,\n        onLoop: null,\n    };\n\n    /**\n     * The speed that the animation will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed = 1;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop = true;\n\n    /**\n     * User-assigned function to call when animation finishes playing. This only happens\n     * if loop is set to `false`.\n     *\n     * @example\n     * animation.onComplete = () => {\n     *   // finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when animation changes which texture is being rendered.\n     *\n     * @example\n     * animation.onFrameChange = () => {\n     *   // updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and animation is played and\n     * loops around to start again. This only happens if loop is set to `true`.\n     *\n     * @example\n     * animation.onLoop = () => {\n     *   // looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    /** The total duration of animation in milliseconds. */\n    public readonly duration: number = 0;\n\n    /** Whether to play the animation after constructing. */\n    public readonly autoPlay: boolean = true;\n\n    /** Collection of frame to render. */\n    private _frames: FrameObject[];\n\n    /** Drawing context reference. */\n    private _context: CanvasRenderingContext2D;\n\n    /** Dirty means the image needs to be redrawn. Set to `true` to force redraw. */\n    public dirty = false;\n\n    /** The current frame number (zero-based index). */\n    private _currentFrame = 0;\n\n    /** `true` uses PIXI.Ticker.shared to auto update animation time.*/\n    private _autoUpdate = false;\n\n    /** `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time. */\n    private _isConnectedToTicker = false;\n\n    /** If animation is currently playing. */\n    private _playing = false;\n\n    /** Current playback position in milliseconds. */\n    private _currentTime = 0;\n\n    /**\n     * Create an animated WebP animation from a WebP image's ArrayBuffer. The easiest way to get\n     * the buffer is to use Assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     * import '@olduvai-jp/pixi-animated-webp';\n     *\n     * const webp = await Assets.load('file.webp');\n     * @param buffer - WebP image arraybuffer from Assets.\n     * @param options - Options to use.\n     * @returns\n     */\n    static async fromBuffer(buffer: ArrayBuffer, options?: Partial<AnimatedWebPOptions>): Promise<AnimatedWebP>\n    {\n        // console.log('AnimatedWebP.fromBuffer called with buffer size:', buffer?.byteLength);\n        // console.log('Options:', options);\n        // console.log('ImageDecoder available?', typeof ImageDecoder !== 'undefined');\n\n        if (!buffer || buffer.byteLength === 0)\n        {\n            throw new Error('Invalid buffer');\n        }\n\n        if (typeof ImageDecoder === 'undefined')\n        {\n            console.error('ImageDecoder API is not supported in this environment');\n            throw new Error('ImageDecoder API is not supported in this environment');\n        }\n\n        const decoder = new ImageDecoder({ data: buffer, type: 'image/webp' });\n\n        await decoder.tracks.ready;\n\n        if (decoder.tracks.length === 0)\n        {\n            throw new Error('No tracks found in WebP');\n        }\n\n        const track = decoder.tracks.selectedTrack;\n\n        if (!track)\n        {\n            throw new Error('No selected track found in WebP');\n        }\n\n        const frameCount = track.frameCount;\n        const frames: FrameObject[] = [];\n        const canvas = DOMAdapter.get().createCanvas();\n        const context = canvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;\n\n        let totalDuration = 0;\n\n        for (let i = 0; i < frameCount; i++)\n        {\n            const { image, complete } = await decoder.decode({ frameIndex: i });\n\n            if (!image || !complete)\n            {\n                continue;\n            }\n\n            // duration is in microseconds, convert to milliseconds\n            const duration = (image as any).duration / 1000;\n\n            canvas.width = image.displayWidth;\n            canvas.height = image.displayHeight;\n            context.drawImage(image, 0, 0);\n            const imageData = context.getImageData(0, 0, image.displayWidth, image.displayHeight);\n\n            frames.push({\n                imageData,\n                start: totalDuration,\n                end: totalDuration + duration,\n            });\n            totalDuration += duration;\n            image.close();\n        }\n\n        decoder.close();\n\n        if (frames.length === 0)\n        {\n            throw new Error('No frames decoded from WebP');\n        }\n\n        const { width, height } = frames[0].imageData;\n\n        return new AnimatedWebP(frames, { width, height, ...options });\n    }\n\n    /**\n     * @param frames - Data of the WebP image.\n     * @param options - Options for the AnimatedWebP\n     */\n    constructor(frames: FrameObject[], options: Partial<AnimatedWebPOptions> & AnimatedWebPSize)\n    {\n        super(Texture.EMPTY);\n\n        // Handle rerenders\n        this.onRender = () => this.updateFrame();\n\n        // Get the options, apply defaults\n        const { scaleMode, width, height, ...rest } = Object.assign({},\n            AnimatedWebP.defaultOptions,\n            options\n        );\n\n        // Create the texture\n        const canvas = DOMAdapter.get().createCanvas(width, height) as HTMLCanvasElement;\n        const context = canvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;\n\n        this.texture = Texture.from(canvas);\n        this.texture.source.scaleMode = scaleMode;\n\n        this.duration = (frames[frames.length - 1] as FrameObject).end;\n        this._frames = frames;\n        this._context = context;\n        this._playing = false;\n        this._currentTime = 0;\n        this._isConnectedToTicker = false;\n        Object.assign(this, rest);\n\n        // Draw the first frame\n        this.currentFrame = 0;\n        if (rest.autoPlay)\n        {\n            this.play();\n        }\n    }\n\n    /** Stops the animation. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the animation. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n\n        // If were on the last frame and stopped, play should resume from beginning\n        if (!this.loop && this.currentFrame === this._frames.length - 1)\n        {\n            this._currentTime = 0;\n        }\n    }\n\n    /**\n     * Get the current progress of the animation from 0 to 1.\n     * @readonly\n     */\n    public get progress(): number\n    {\n        return this._currentTime / this.duration;\n    }\n\n    /** `true` if the current animation is playing */\n    public get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /**\n     * Updates the object transform for rendering. You only need to call this\n     * if the `autoUpdate` property is set to `false`.\n     *\n     * @param deltaTime - Time since last tick.\n     */\n    update(ticker: Ticker): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        const elapsed = this.animationSpeed * ticker.elapsedMS;\n\n        this._currentTime += elapsed;\n\n        const localTime = this._currentTime % this.duration;\n\n        const frameIndex = this._frames.findIndex((frame) => localTime >= frame.start && localTime < frame.end);\n\n        // If no frame found (single-frame WebP), no need to update\n        if (frameIndex === -1)\n        {\n            return;\n        }\n\n        if (this._currentTime >= this.duration)\n        {\n            if (this.loop)\n            {\n                this._currentTime = localTime;\n                this.updateFrameIndex(frameIndex);\n                this.onLoop?.();\n            }\n            else\n            {\n                this._currentTime = this.duration;\n                this.updateFrameIndex(this.totalFrames - 1);\n                this.onComplete?.();\n                this.stop();\n            }\n        }\n        else\n        {\n            this.updateFrameIndex(frameIndex);\n        }\n    }\n\n    /**\n     * Redraw the current frame, is necessary for the animation to work when\n     */\n    private updateFrame(): void\n    {\n        if (!this.dirty)\n        {\n            return;\n        }\n\n        // Update the current frame\n        const { imageData } = this._frames[this._currentFrame] as FrameObject;\n\n        this._context.putImageData(imageData, 0, 0);\n\n        // Workaround hack for Safari & iOS\n        // which fails to upload canvas after putImageData\n        // See: https://bugs.webkit.org/show_bug.cgi?id=229986\n        this._context.fillStyle = 'transparent';\n        this._context.fillRect(0, 0, 0, 1);\n        this.texture.source.update();\n\n        // Mark as clean\n        this.dirty = false;\n    }\n\n    /**\n     * Whether to use PIXI.Ticker.shared to auto update animation time.\n     * @default true\n     */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /** Set the current frame number */\n    get currentFrame(): number\n    {\n        return this._currentFrame;\n    }\n    set currentFrame(value: number)\n    {\n        this.updateFrameIndex(value);\n        this._currentTime = (this._frames[value] as FrameObject).start;\n    }\n\n    /** Internally handle updating the frame index */\n    private updateFrameIndex(value: number): void\n    {\n        if (value < 0 || value >= this._frames.length)\n        {\n            throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${value}`);\n        }\n        if (this._currentFrame !== value)\n        {\n            this._currentFrame = value;\n            this.dirty = true;\n            this.onFrameChange?.(value);\n        }\n    }\n\n    /**\n     * Get the total number of frame in the WebP.\n     */\n    get totalFrames(): number\n    {\n        return this._frames.length;\n    }\n\n    /** Destroy and don't use after this. */\n    destroy(): void\n    {\n        this.stop();\n        super.destroy(true);\n\n        const forceClear = null as any;\n\n        this._context = forceClear;\n        this._frames = forceClear;\n        this.onComplete = forceClear;\n        this.onFrameChange = forceClear;\n        this.onLoop = forceClear;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedWebP from an array of frame textures.\n     *\n     * @param frames - The array of frames to create the AnimatedWebP from.\n     * @param autoUpdate - Whether to use the shared ticker for animation updates.\n     * @returns The new AnimatedWebP instance.\n     */\n    static fromFrames(frames: FrameObject[], autoUpdate = true): AnimatedWebP\n    {\n        if (!frames || frames.length === 0)\n        {\n            throw new Error('No frames provided');\n        }\n\n        const { width, height } = frames[0].imageData;\n\n        return new AnimatedWebP(frames, {\n            width,\n            height,\n            autoUpdate,\n        });\n    }\n\n    /**\n     * A short hand way of creating an AnimatedWebP from a single frame.\n     *\n     * @param imageData - The ImageData for the frame.\n     * @param duration - Duration of the frame in milliseconds.\n     * @returns The new AnimatedWebP instance.\n     */\n    static fromImageData(imageData: ImageData, duration = 1000): AnimatedWebP\n    {\n        const frame: FrameObject = {\n            imageData,\n            start: 0,\n            end: duration,\n        };\n\n        return new AnimatedWebP([frame], {\n            width: imageData.width,\n            height: imageData.height,\n        });\n    }\n\n    /**\n     * Clone the current AnimatedWebP.\n     * @returns A new AnimatedWebP instance with the same frames and options.\n     */\n    clone(): AnimatedWebP\n    {\n        return new AnimatedWebP(this._frames, {\n            width: this.texture.width,\n            height: this.texture.height,\n            scaleMode: this.texture.source.scaleMode,\n            animationSpeed: this.animationSpeed,\n            loop: this.loop,\n            autoPlay: false,\n            autoUpdate: this._autoUpdate,\n            onComplete: this.onComplete,\n            onFrameChange: this.onFrameChange,\n            onLoop: this.onLoop,\n        });\n    }\n}\n\nexport { AnimatedWebP, AnimatedWebPOptions, AnimatedWebPSize, FrameObject };\n"],"names":["Sprite","Texture","DOMAdapter","Ticker","UPDATE_PRIORITY"],"mappings":"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"}