/*!
 * @olduvai-jp/pixi-animated-webp - v1.0.4
 * Compiled Thu, 03 Jul 2025 05:53:24 UTC
 *
 * @olduvai-jp/pixi-animated-webp is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2025, dyamagishi <dyamagishi@olduvai.jp>, All Rights Reserved
 */import{Sprite as P,Texture as _,DOMAdapter as m,Ticker as l,UPDATE_PRIORITY as k,ExtensionType as y,path as D,extensions as O}from"pixi.js";var U=Object.defineProperty,u=Object.getOwnPropertySymbols,w=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable,x=(t,a,e)=>a in t?U(t,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[a]=e,E=(t,a)=>{for(var e in a||(a={}))w.call(a,e)&&x(t,e,a[e]);if(u)for(var e of u(a))T.call(a,e)&&x(t,e,a[e]);return t},A=(t,a)=>{var e={};for(var i in t)w.call(t,i)&&a.indexOf(i)<0&&(e[i]=t[i]);if(t!=null&&u)for(var i of u(t))a.indexOf(i)<0&&T.call(t,i)&&(e[i]=t[i]);return e};const h=class extends P{constructor(t,a){super(_.EMPTY),this.animationSpeed=1,this.loop=!0,this.duration=0,this.autoPlay=!0,this.dirty=!1,this._currentFrame=0,this._autoUpdate=!1,this._isConnectedToTicker=!1,this._playing=!1,this._currentTime=0,this.onRender=()=>this.updateFrame();const e=Object.assign({},h.defaultOptions,a),{scaleMode:i,width:o,height:r}=e,s=A(e,["scaleMode","width","height"]),d=m.get().createCanvas(o,r),c=d.getContext("2d",{willReadFrequently:!0});this.texture=_.from(d),this.texture.source.scaleMode=i,this.duration=t[t.length-1].end,this._frames=t,this._context=c,this._playing=!1,this._currentTime=0,this._isConnectedToTicker=!1,Object.assign(this,s),this.currentFrame=0,s.autoPlay&&this.play()}static async fromBuffer(t,a){if(!t||t.byteLength===0)throw new Error("Invalid buffer");if(typeof ImageDecoder=="undefined")throw console.error("ImageDecoder API is not supported in this environment"),new Error("ImageDecoder API is not supported in this environment");const e=new ImageDecoder({data:t,type:"image/webp"});if(await e.tracks.ready,e.tracks.length===0)throw new Error("No tracks found in WebP");const i=e.tracks.selectedTrack;if(!i)throw new Error("No selected track found in WebP");const o=i.frameCount,r=[],s=m.get().createCanvas(),d=s.getContext("2d",{willReadFrequently:!0});let c=0;for(let p=0;p<o;p++){const{image:n,complete:v}=await e.decode({frameIndex:p});if(!n||!v)continue;const f=n.duration/1e3;s.width=n.displayWidth,s.height=n.displayHeight,d.drawImage(n,0,0);const I=d.getImageData(0,0,n.displayWidth,n.displayHeight);r.push({imageData:I,start:c,end:c+f}),c+=f,n.close()}if(e.close(),r.length===0)throw new Error("No frames decoded from WebP");const{width:C,height:b}=r[0].imageData;return new h(r,E({width:C,height:b},a))}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(l.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(l.shared.add(this.update,this,k.HIGH),this._isConnectedToTicker=!0),!this.loop&&this.currentFrame===this._frames.length-1&&(this._currentTime=0))}get progress(){return this._currentTime/this.duration}get playing(){return this._playing}update(t){var a,e;if(!this._playing)return;const i=this.animationSpeed*t.elapsedMS;this._currentTime+=i;const o=this._currentTime%this.duration,r=this._frames.findIndex(s=>o>=s.start&&o<s.end);r!==-1&&(this._currentTime>=this.duration?this.loop?(this._currentTime=o,this.updateFrameIndex(r),(a=this.onLoop)==null||a.call(this)):(this._currentTime=this.duration,this.updateFrameIndex(this.totalFrames-1),(e=this.onComplete)==null||e.call(this),this.stop()):this.updateFrameIndex(r))}updateFrame(){if(!this.dirty)return;const{imageData:t}=this._frames[this._currentFrame];this._context.putImageData(t,0,0),this._context.fillStyle="transparent",this._context.fillRect(0,0,0,1),this.texture.source.update(),this.dirty=!1}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(l.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(l.shared.add(this.update,this),this._isConnectedToTicker=!0))}get currentFrame(){return this._currentFrame}set currentFrame(t){this.updateFrameIndex(t),this._currentTime=this._frames[t].start}updateFrameIndex(t){var a;if(t<0||t>=this._frames.length)throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${t}`);this._currentFrame!==t&&(this._currentFrame=t,this.dirty=!0,(a=this.onFrameChange)==null||a.call(this,t))}get totalFrames(){return this._frames.length}destroy(){this.stop(),super.destroy(!0);const t=null;this._context=t,this._frames=t,this.onComplete=t,this.onFrameChange=t,this.onLoop=t}static fromFrames(t,a=!0){if(!t||t.length===0)throw new Error("No frames provided");const{width:e,height:i}=t[0].imageData;return new h(t,{width:e,height:i,autoUpdate:a})}static fromImageData(t,a=1e3){const e={imageData:t,start:0,end:a};return new h([e],{width:t.width,height:t.height})}clone(){return new h(this._frames,{width:this.texture.width,height:this.texture.height,scaleMode:this.texture.source.scaleMode,animationSpeed:this.animationSpeed,loop:this.loop,autoPlay:!1,autoUpdate:this._autoUpdate,onComplete:this.onComplete,onFrameChange:this.onFrameChange,onLoop:this.onLoop})}};let g=h;g.defaultOptions={scaleMode:"linear",fps:30,loop:!0,animationSpeed:1,autoPlay:!0,autoUpdate:!0,onComplete:null,onFrameChange:null,onLoop:null};const F={extension:y.Asset,detection:{test:async()=>!0,add:async t=>[...t,"webp"],remove:async t=>t.filter(a=>a!=="webp")},loader:{name:"animatedWebpLoader",extension:{type:y.LoadParser,priority:10},test:t=>D.extname(t)===".webp",load:async(t,a)=>{try{const e=await(await m.get().fetch(t)).arrayBuffer();return await g.fromBuffer(e,a==null?void 0:a.data)}catch(e){throw console.error("Error in AnimatedWebPAsset loader:",e),e}},unload:async t=>{t.destroy()}}};O.add(F);export{g as AnimatedWebP,F as AnimatedWebPAsset};
//# sourceMappingURL=olduvai-jp-pixi-animated-webp.mjs.map
