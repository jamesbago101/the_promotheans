{"version":3,"file":"olduvai-jp-pixi-animated-webp.js","sources":["../src/AnimatedWebP.ts","../src/AnimatedWebPAsset.ts"],"sourcesContent":["import { DOMAdapter, SCALE_MODE, Sprite, Texture, Ticker, UPDATE_PRIORITY } from 'pixi.js';\n\n/** Represents a single frame of a WebP. Includes image and timing data. */\ninterface FrameObject\n{\n    /** Image data for the current frame */\n    imageData: ImageData;\n    /** The start of the current frame, in milliseconds */\n    start: number;\n    /** The end of the current frame, in milliseconds */\n    end: number;\n}\n\n/** Default options for all AnimatedWebP objects. */\ninterface AnimatedWebPOptions\n{\n    /** Whether to start playing right away */\n    autoPlay: boolean;\n    /**\n     * Scale Mode to use for the texture\n     * @type {PIXI.SCALE_MODE}\n     */\n    scaleMode: SCALE_MODE;\n    /** To enable looping */\n    loop: boolean;\n    /** Speed of the animation */\n    animationSpeed: number;\n    /** Set to `false` to manage updates yourself */\n    autoUpdate: boolean;\n    /** The completed callback, optional */\n    onComplete: null | (() => void);\n    /** The loop callback, optional */\n    onLoop: null | (() => void);\n    /** The frame callback, optional */\n    onFrameChange: null | ((currentFrame: number) => void);\n    /** Fallback FPS if WebP contains no time information */\n    fps?: number;\n}\n\n/** Options for the AnimatedWebP constructor. */\ninterface AnimatedWebPSize\n{\n    /** Width of the WebP image */\n    width: number;\n    /** Height of the WebP image */\n    height: number;\n}\n\n/**\n * Runtime object to play animated WebPs. This object is similar to an AnimatedSprite.\n * It support playback (seek, play, stop) as well as animation speed and looping.\n * @see Uses ImageDecoder API for WebP decoding\n */\nclass AnimatedWebP extends Sprite\n{\n    /**\n     * Default options for all AnimatedWebP objects.\n     * @property {PIXI.SCALE_MODE} [scaleMode='linear'] - Scale mode to use for the texture.\n     * @property {boolean} [loop=true] - To enable looping.\n     * @property {number} [animationSpeed=1] - Speed of the animation.\n     * @property {boolean} [autoUpdate=true] - Set to `false` to manage updates yourself.\n     * @property {boolean} [autoPlay=true] - To start playing right away.\n     * @property {Function} [onComplete=null] - The completed callback, optional.\n     * @property {Function} [onLoop=null] - The loop callback, optional.\n     * @property {Function} [onFrameChange=null] - The frame callback, optional.\n     * @property {number} [fps=30] - Fallback FPS if WebP contains no time information.\n     */\n    public static defaultOptions: AnimatedWebPOptions = {\n        scaleMode: 'linear',\n        fps: 30,\n        loop: true,\n        animationSpeed: 1,\n        autoPlay: true,\n        autoUpdate: true,\n        onComplete: null,\n        onFrameChange: null,\n        onLoop: null,\n    };\n\n    /**\n     * The speed that the animation will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed = 1;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop = true;\n\n    /**\n     * User-assigned function to call when animation finishes playing. This only happens\n     * if loop is set to `false`.\n     *\n     * @example\n     * animation.onComplete = () => {\n     *   // finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when animation changes which texture is being rendered.\n     *\n     * @example\n     * animation.onFrameChange = () => {\n     *   // updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and animation is played and\n     * loops around to start again. This only happens if loop is set to `true`.\n     *\n     * @example\n     * animation.onLoop = () => {\n     *   // looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    /** The total duration of animation in milliseconds. */\n    public readonly duration: number = 0;\n\n    /** Whether to play the animation after constructing. */\n    public readonly autoPlay: boolean = true;\n\n    /** Collection of frame to render. */\n    private _frames: FrameObject[];\n\n    /** Drawing context reference. */\n    private _context: CanvasRenderingContext2D;\n\n    /** Dirty means the image needs to be redrawn. Set to `true` to force redraw. */\n    public dirty = false;\n\n    /** The current frame number (zero-based index). */\n    private _currentFrame = 0;\n\n    /** `true` uses PIXI.Ticker.shared to auto update animation time.*/\n    private _autoUpdate = false;\n\n    /** `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time. */\n    private _isConnectedToTicker = false;\n\n    /** If animation is currently playing. */\n    private _playing = false;\n\n    /** Current playback position in milliseconds. */\n    private _currentTime = 0;\n\n    /**\n     * Create an animated WebP animation from a WebP image's ArrayBuffer. The easiest way to get\n     * the buffer is to use Assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     * import '@olduvai-jp/pixi-animated-webp';\n     *\n     * const webp = await Assets.load('file.webp');\n     * @param buffer - WebP image arraybuffer from Assets.\n     * @param options - Options to use.\n     * @returns\n     */\n    static async fromBuffer(buffer: ArrayBuffer, options?: Partial<AnimatedWebPOptions>): Promise<AnimatedWebP>\n    {\n        // console.log('AnimatedWebP.fromBuffer called with buffer size:', buffer?.byteLength);\n        // console.log('Options:', options);\n        // console.log('ImageDecoder available?', typeof ImageDecoder !== 'undefined');\n\n        if (!buffer || buffer.byteLength === 0)\n        {\n            throw new Error('Invalid buffer');\n        }\n\n        if (typeof ImageDecoder === 'undefined')\n        {\n            console.error('ImageDecoder API is not supported in this environment');\n            throw new Error('ImageDecoder API is not supported in this environment');\n        }\n\n        const decoder = new ImageDecoder({ data: buffer, type: 'image/webp' });\n\n        await decoder.tracks.ready;\n\n        if (decoder.tracks.length === 0)\n        {\n            throw new Error('No tracks found in WebP');\n        }\n\n        const track = decoder.tracks.selectedTrack;\n\n        if (!track)\n        {\n            throw new Error('No selected track found in WebP');\n        }\n\n        const frameCount = track.frameCount;\n        const frames: FrameObject[] = [];\n        const canvas = DOMAdapter.get().createCanvas();\n        const context = canvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;\n\n        let totalDuration = 0;\n\n        for (let i = 0; i < frameCount; i++)\n        {\n            const { image, complete } = await decoder.decode({ frameIndex: i });\n\n            if (!image || !complete)\n            {\n                continue;\n            }\n\n            // duration is in microseconds, convert to milliseconds\n            const duration = (image as any).duration / 1000;\n\n            canvas.width = image.displayWidth;\n            canvas.height = image.displayHeight;\n            context.drawImage(image, 0, 0);\n            const imageData = context.getImageData(0, 0, image.displayWidth, image.displayHeight);\n\n            frames.push({\n                imageData,\n                start: totalDuration,\n                end: totalDuration + duration,\n            });\n            totalDuration += duration;\n            image.close();\n        }\n\n        decoder.close();\n\n        if (frames.length === 0)\n        {\n            throw new Error('No frames decoded from WebP');\n        }\n\n        const { width, height } = frames[0].imageData;\n\n        return new AnimatedWebP(frames, { width, height, ...options });\n    }\n\n    /**\n     * @param frames - Data of the WebP image.\n     * @param options - Options for the AnimatedWebP\n     */\n    constructor(frames: FrameObject[], options: Partial<AnimatedWebPOptions> & AnimatedWebPSize)\n    {\n        super(Texture.EMPTY);\n\n        // Handle rerenders\n        this.onRender = () => this.updateFrame();\n\n        // Get the options, apply defaults\n        const { scaleMode, width, height, ...rest } = Object.assign({},\n            AnimatedWebP.defaultOptions,\n            options\n        );\n\n        // Create the texture\n        const canvas = DOMAdapter.get().createCanvas(width, height) as HTMLCanvasElement;\n        const context = canvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;\n\n        this.texture = Texture.from(canvas);\n        this.texture.source.scaleMode = scaleMode;\n\n        this.duration = (frames[frames.length - 1] as FrameObject).end;\n        this._frames = frames;\n        this._context = context;\n        this._playing = false;\n        this._currentTime = 0;\n        this._isConnectedToTicker = false;\n        Object.assign(this, rest);\n\n        // Draw the first frame\n        this.currentFrame = 0;\n        if (rest.autoPlay)\n        {\n            this.play();\n        }\n    }\n\n    /** Stops the animation. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the animation. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n\n        // If were on the last frame and stopped, play should resume from beginning\n        if (!this.loop && this.currentFrame === this._frames.length - 1)\n        {\n            this._currentTime = 0;\n        }\n    }\n\n    /**\n     * Get the current progress of the animation from 0 to 1.\n     * @readonly\n     */\n    public get progress(): number\n    {\n        return this._currentTime / this.duration;\n    }\n\n    /** `true` if the current animation is playing */\n    public get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /**\n     * Updates the object transform for rendering. You only need to call this\n     * if the `autoUpdate` property is set to `false`.\n     *\n     * @param deltaTime - Time since last tick.\n     */\n    update(ticker: Ticker): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        const elapsed = this.animationSpeed * ticker.elapsedMS;\n\n        this._currentTime += elapsed;\n\n        const localTime = this._currentTime % this.duration;\n\n        const frameIndex = this._frames.findIndex((frame) => localTime >= frame.start && localTime < frame.end);\n\n        // If no frame found (single-frame WebP), no need to update\n        if (frameIndex === -1)\n        {\n            return;\n        }\n\n        if (this._currentTime >= this.duration)\n        {\n            if (this.loop)\n            {\n                this._currentTime = localTime;\n                this.updateFrameIndex(frameIndex);\n                this.onLoop?.();\n            }\n            else\n            {\n                this._currentTime = this.duration;\n                this.updateFrameIndex(this.totalFrames - 1);\n                this.onComplete?.();\n                this.stop();\n            }\n        }\n        else\n        {\n            this.updateFrameIndex(frameIndex);\n        }\n    }\n\n    /**\n     * Redraw the current frame, is necessary for the animation to work when\n     */\n    private updateFrame(): void\n    {\n        if (!this.dirty)\n        {\n            return;\n        }\n\n        // Update the current frame\n        const { imageData } = this._frames[this._currentFrame] as FrameObject;\n\n        this._context.putImageData(imageData, 0, 0);\n\n        // Workaround hack for Safari & iOS\n        // which fails to upload canvas after putImageData\n        // See: https://bugs.webkit.org/show_bug.cgi?id=229986\n        this._context.fillStyle = 'transparent';\n        this._context.fillRect(0, 0, 0, 1);\n        this.texture.source.update();\n\n        // Mark as clean\n        this.dirty = false;\n    }\n\n    /**\n     * Whether to use PIXI.Ticker.shared to auto update animation time.\n     * @default true\n     */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /** Set the current frame number */\n    get currentFrame(): number\n    {\n        return this._currentFrame;\n    }\n    set currentFrame(value: number)\n    {\n        this.updateFrameIndex(value);\n        this._currentTime = (this._frames[value] as FrameObject).start;\n    }\n\n    /** Internally handle updating the frame index */\n    private updateFrameIndex(value: number): void\n    {\n        if (value < 0 || value >= this._frames.length)\n        {\n            throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${value}`);\n        }\n        if (this._currentFrame !== value)\n        {\n            this._currentFrame = value;\n            this.dirty = true;\n            this.onFrameChange?.(value);\n        }\n    }\n\n    /**\n     * Get the total number of frame in the WebP.\n     */\n    get totalFrames(): number\n    {\n        return this._frames.length;\n    }\n\n    /** Destroy and don't use after this. */\n    destroy(): void\n    {\n        this.stop();\n        super.destroy(true);\n\n        const forceClear = null as any;\n\n        this._context = forceClear;\n        this._frames = forceClear;\n        this.onComplete = forceClear;\n        this.onFrameChange = forceClear;\n        this.onLoop = forceClear;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedWebP from an array of frame textures.\n     *\n     * @param frames - The array of frames to create the AnimatedWebP from.\n     * @param autoUpdate - Whether to use the shared ticker for animation updates.\n     * @returns The new AnimatedWebP instance.\n     */\n    static fromFrames(frames: FrameObject[], autoUpdate = true): AnimatedWebP\n    {\n        if (!frames || frames.length === 0)\n        {\n            throw new Error('No frames provided');\n        }\n\n        const { width, height } = frames[0].imageData;\n\n        return new AnimatedWebP(frames, {\n            width,\n            height,\n            autoUpdate,\n        });\n    }\n\n    /**\n     * A short hand way of creating an AnimatedWebP from a single frame.\n     *\n     * @param imageData - The ImageData for the frame.\n     * @param duration - Duration of the frame in milliseconds.\n     * @returns The new AnimatedWebP instance.\n     */\n    static fromImageData(imageData: ImageData, duration = 1000): AnimatedWebP\n    {\n        const frame: FrameObject = {\n            imageData,\n            start: 0,\n            end: duration,\n        };\n\n        return new AnimatedWebP([frame], {\n            width: imageData.width,\n            height: imageData.height,\n        });\n    }\n\n    /**\n     * Clone the current AnimatedWebP.\n     * @returns A new AnimatedWebP instance with the same frames and options.\n     */\n    clone(): AnimatedWebP\n    {\n        return new AnimatedWebP(this._frames, {\n            width: this.texture.width,\n            height: this.texture.height,\n            scaleMode: this.texture.source.scaleMode,\n            animationSpeed: this.animationSpeed,\n            loop: this.loop,\n            autoPlay: false,\n            autoUpdate: this._autoUpdate,\n            onComplete: this.onComplete,\n            onFrameChange: this.onFrameChange,\n            onLoop: this.onLoop,\n        });\n    }\n}\n\nexport { AnimatedWebP, AnimatedWebPOptions, AnimatedWebPSize, FrameObject };\n","import { DOMAdapter, extensions, ExtensionType, path } from 'pixi.js';\nimport { AnimatedWebP, AnimatedWebPOptions } from './AnimatedWebP';\n\nimport type { AssetExtension } from 'pixi.js';\n\n/**\n * Handle the loading of WebP images. Registering this loader plugin will\n * load all `.webp` images as an ArrayBuffer and transform into an\n * AnimatedWebP object.\n * @ignore\n */\nconst AnimatedWebPAsset = {\n    extension: ExtensionType.Asset,\n    detection: {\n        test: async () => true,\n        add: async (formats) => [...formats, 'webp'],\n        remove: async (formats) => formats.filter((format) => format !== 'webp'),\n    },\n    loader: {\n        name: 'animatedWebpLoader',\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: 10,\n        },\n        test: (url) =>\n        {\n            const isWebP = path.extname(url) === '.webp';\n\n            return isWebP;\n        },\n        load: async (url, asset) =>\n        {\n            try\n            {\n                const response = await DOMAdapter.get().fetch(url);\n                const buffer = await response.arrayBuffer();\n                const result = await AnimatedWebP.fromBuffer(buffer, asset?.data);\n\n                return result;\n            }\n            catch (error)\n            {\n                console.error('Error in AnimatedWebPAsset loader:', error);\n                throw error;\n            }\n        },\n        unload: async (asset) =>\n        {\n            asset.destroy();\n        },\n    }\n} as AssetExtension<AnimatedWebP, AnimatedWebPOptions>;\n\nextensions.add(AnimatedWebPAsset);\nexport { AnimatedWebPAsset };\n"],"names":["_AnimatedWebP","Sprite","frames","options","Texture","_a","scaleMode","width","height","rest","__objRest","canvas","DOMAdapter","context","buffer","decoder","track","frameCount","totalDuration","i","image","complete","duration","imageData","__spreadValues","Ticker","UPDATE_PRIORITY","ticker","_b","elapsed","localTime","frameIndex","frame","value","forceClear","autoUpdate","AnimatedWebP","AnimatedWebPAsset","ExtensionType","formats","format","url","path","asset","error","extensions"],"mappings":"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"}